
Function dijkstra(graph, source_node):
  dist = {}  // {node: []} âˆž
  dist[source_node] = 0

  min_heap = [[node, distance_to_node], [node, distance_to_node]]  // build_min_heap
  insert_min_heap(min_heap, [0, source_node])  // (distance, node) this add the source/start node to the heap

  while min_heap is not empty:
    (current_distance, current_node) = extract_min_heap(min_heap)

    if current_node is already visited:
      continue

    mark current_node as visited

    // this is where the node is use to interact with the graph based on it position
    for each neighbor in graph[current_node]:
      distance = current_distance + weight to neighbor

      if distance < dist[neighbor]:
          dist[neighbor] = distance
          min_heap.insert((distance, neighbor))

  return dist

function extract_min_heap(heap)
  if heap is null or empty
    return null

  min = heap[0]
  heap[0] = heap[heap.length - 1]
  heap.pop // remove the last

  index = 0

  while heap[2 * index + 1] is not null
    left = 2 * index + 1
    right = 2 * index + 2
    min_index = right

    if right < heap.length and heap[left] > heap[right]
      min_index = left

    if heap[index] > heap[min_index]
      swap(heap, index, min_index)
      index = min_index

  return min

function insert_min_heap(heap, value)
  heap.append(value)
  index = heap.length - 1

  while index > 0
    parent = index / 2
    if heap[parent] > heap[index]
      swap(heap, index, parent)
      index = parent
    else
      break

  return heap
